import { StatusManager } from "./StatusManager";
import {
	CodeGenerationService,
	CodeGenerationRequest,
} from "./CodeGenerationService";
import { Dataset } from "./AnalysisPlanner";
import { AsyncUtils } from "../utils/AsyncUtils";
import { EventManager } from "../utils/EventManager";

export interface NotebookCell {
	id: string;
	code: string;
	language: "python" | "r" | "markdown";
	output?: string;
	status?: "pending" | "running" | "completed" | "failed";
	title?: string;
}

export interface NotebookOptions {
	workspacePath: string;
	statusManager?: StatusManager;
	codeGenerationService?: CodeGenerationService;
	kernelName?: string;
}

export class NotebookService {
	private workspacePath: string;
	private statusManager: StatusManager;
	private codeGenerationService?: CodeGenerationService;
	private kernelName: string;

	constructor(options: NotebookOptions) {
		this.workspacePath = options.workspacePath;
		this.statusManager = options.statusManager || StatusManager.getInstance();
		this.codeGenerationService = options.codeGenerationService;
		this.kernelName = options.kernelName || "python3";
	}

	updateWorkspacePath(newWorkspacePath: string) {
		console.log(`NotebookService: Updating workspace path from ${this.workspacePath} to ${newWorkspacePath}`);
		this.workspacePath = newWorkspacePath;
	}

	/**
	 * Add a markdown cell to a notebook
	 */
	async addMarkdownCell(notebookPath: string, content: string): Promise<void> {
		this.statusManager.updateStatus("Adding markdown cell...");
		EventManager.dispatchEvent("add-notebook-cell", {
			filePath: notebookPath,
			cellType: "markdown",
			content: content,
		});
		await EventManager.waitForEvent("notebook-cell-added");
		this.statusManager.updateStatus("Markdown cell added successfully");
	}

	/**
	 * Add a code cell to a notebook
	 */
	async addCodeCell(notebookPath: string, code: string): Promise<void> {
		this.statusManager.updateStatus("Adding code cell...");
		EventManager.dispatchEvent("add-notebook-cell", {
			filePath: notebookPath,
			cellType: "code",
			content: code,
		});
		await EventManager.waitForEvent("notebook-cell-added");
		this.statusManager.updateStatus("Code cell added successfully");
	}

	/**
	 * Update cell output in a notebook
	 */
	async updateCellOutput(
		notebookPath: string,
		cellIndex: number,
		output: string,
		workspaceDir: string
	): Promise<void> {
		// Handle -1 index for last cell
		let actualCellIndex = cellIndex;
		if (cellIndex === -1) {
			// Read the notebook to get the last cell index
			try {
				const notebookContent = await window.electronAPI.readFile(
					notebookPath
				);
				const notebook = JSON.parse(notebookContent);
				actualCellIndex = notebook.cells.length - 1;
			} catch (error) {
				console.error("Failed to determine last cell index:", error);
				return; // Skip update if we can't determine the index
			}
		}

		this.statusManager.updateStatus(
			`Updating cell ${actualCellIndex + 1} output...`
		);

		EventManager.dispatchEvent("update-notebook-cell", {
			filePath: notebookPath,
			cellIndex: actualCellIndex,
			output: output,
		});

		await EventManager.waitForEvent("notebook-cell-updated");

		this.statusManager.updateStatus(
			`Cell ${actualCellIndex + 1} output updated`
		);
	}

	/**
	 * Create an empty notebook file with basic structure
	 */
	async createEmptyNotebook(
		query: string,
		datasets: Dataset[],
		workspaceDir: string
	): Promise<string> {
		try {
			this.statusManager.updateStatus("Creating empty notebook...");

			const notebookPath = `${workspaceDir}/analysis_${Date.now()}.ipynb`;

			// Create empty notebook with just header
			const notebook = {
				cells: [
					{
						cell_type: "markdown",
						metadata: {},
						source: [
							`# Analysis: ${query}\n\n`,
							`This notebook will contain your analysis pipeline.\n\n`,
							`## Selected Datasets\n`,
							datasets.map(d => `- **${d.id}**: ${d.title} (${d.organism})`).join('\n'),
							`\n\n---\n`,
							`*Generated by Axon AI*`
						]
					}
				],
				metadata: {
					kernelspec: {
						display_name: this.kernelName.startsWith("axon-") ? "Axon Python Environment" : "Python 3",
						language: "python",
						name: this.kernelName,
					},
					language_info: {
						codemirror_mode: {
							name: "ipython",
							version: 3,
						},
						file_extension: ".py",
						mimetype: "text/x-python",
						name: "python",
						nbconvert_exporter: "python",
						pygments_lexer: "ipython3",
						version: "3.8.0",
					},
				},
				nbformat: 4,
				nbformat_minor: 4,
			};

			// Write the notebook file to disk
			await window.electronAPI.writeFile(
				notebookPath,
				JSON.stringify(notebook, null, 2)
			);

			this.statusManager.updateStatus("Empty notebook created successfully");
			return notebookPath;
		} catch (error) {
			console.error("NotebookService: Error creating empty notebook:", error);
			this.statusManager.updateStatus("Failed to create empty notebook");
			throw error;
		}
	}

	/**
	 * Create a complete notebook with cells
	 */
	async createNotebook(
		notebookPath: string,
		cells: NotebookCell[]
	): Promise<void> {
		try {
			this.statusManager.updateStatus("Creating notebook...");

			// Convert cells to Jupyter notebook format
			const notebookCells = cells.map((cell) => {
				if (cell.language === "markdown") {
					return {
						cell_type: "markdown",
						metadata: {},
						source: cell.code,
					};
				} else {
					return {
						cell_type: "code",
						execution_count: null,
						metadata: {},
						outputs: [],
						source: cell.code,
					};
				}
			});

			// Create the notebook structure
			const notebook = {
				cells: notebookCells,
				metadata: {
					kernelspec: {
						display_name: this.kernelName.startsWith("axon-") ? "Axon Python Environment" : "Python 3",
						language: "python",
						name: this.kernelName,
					},
					language_info: {
						codemirror_mode: {
							name: "ipython",
							version: 3,
						},
						file_extension: ".py",
						mimetype: "text/x-python",
						name: "python",
						nbconvert_exporter: "python",
						pygments_lexer: "ipython3",
						version: "3.8.0",
					},
				},
				nbformat: 4,
				nbformat_minor: 4,
			};

			// Write the notebook file to disk
			await window.electronAPI.writeFile(
				notebookPath,
				JSON.stringify(notebook, null, 2)
			);

			this.statusManager.updateStatus("Notebook created successfully");
		} catch (error) {
			console.error("NotebookService: Error creating notebook:", error);
			this.statusManager.updateStatus("Failed to create notebook");
			throw error;
		}
	}

	/**
	 * Generate a data download notebook with AI-generated code
	 */
	async generateDataDownloadNotebook(
		query: string,
		datasets: Dataset[],
		workspaceDir: string
	): Promise<string> {
		try {
			this.statusManager.updateStatus("Generating data download notebook...");

			const notebookPath = `${workspaceDir}/data_download_${Date.now()}.ipynb`;

			// Create notebook structure
			const cells: NotebookCell[] = [
				{
					id: "header",
					code: `# Data Download & Preprocessing\n\nThis notebook was generated by the AI agent for your question:\n\n> ${query}\n\n## Selected Datasets\n${datasets
						.map((d, i) => `- **${d.id}**: ${d.title} (${d.organism})`)
						.join(
							"\n"
						)}\n\n---\nYou can run each cell to download and preprocess the data yourself.`,
					language: "markdown",
				},
				{
					id: "setup",
					code: `# Setup and Imports
import pandas as pd
import numpy as np
import requests
import os
from pathlib import Path

# Create data directory
data_dir = Path('data')
data_dir.mkdir(exist_ok=True)

print("Setup completed successfully!")`,
					language: "python",
				},
			];

			// Add dataset download cells with AI-generated code if available
			for (let i = 0; i < datasets.length; i++) {
				const dataset = datasets[i];
				this.statusManager.updateStatus(
					`Generating download code for dataset ${i + 1}/${datasets.length}: ${
						dataset.id
					}`
				);

				let code: string;
				if (this.codeGenerationService) {
					// Use AI to generate download code
					const request: CodeGenerationRequest = {
						stepDescription: `Download and preprocess dataset ${dataset.id} (${dataset.title})`,
						originalQuestion: query,
						datasets: [dataset],
						workingDir: workspaceDir,
						stepIndex: i,
					};

					const result =
						await this.codeGenerationService.generateDataDrivenStepCode(
							request
						);
					code = result.code;
				} else {
					// Fallback to basic template
					code = `# Download Dataset: ${dataset.title}
print(f"Downloading dataset: {dataset.title}")

# TODO: Implement download logic for ${dataset.id}
# URL: ${dataset.url || "Not available"}

print("Dataset download completed!")`;
				}

				cells.push({
					id: `dataset-${dataset.id}`,
					code: code,
					language: "python",
				});
			}

			await this.createNotebook(notebookPath, cells);

			this.statusManager.updateStatus(
				"Data download notebook generated successfully"
			);
			return notebookPath;
		} catch (error) {
			console.error(
				"NotebookService: Error generating data download notebook:",
				error
			);
			this.statusManager.updateStatus(
				"Failed to generate data download notebook"
			);
			throw error;
		}
	}

	/**
	 * Generate a unified analysis notebook with AI-generated code
	 */
	async generateUnifiedNotebook(
		query: string,
		datasets: Dataset[],
		analysisSteps: any[],
		workspaceDir: string
	): Promise<string> {
		try {
			this.statusManager.updateStatus(
				"Generating unified analysis notebook..."
			);

			const notebookPath = `${workspaceDir}/analysis_${Date.now()}.ipynb`;

			// Create notebook structure
			const cells: NotebookCell[] = [
				{
					id: "header",
					code: `# Complete Analysis: ${query}\n\nThis notebook contains the complete analysis pipeline including data download and analysis.\n\n## Selected Datasets\n${datasets
						.map((d, i) => `- **${d.id}**: ${d.title} (${d.organism})`)
						.join("\n")}\n\n## Analysis Steps\n${analysisSteps
						.map((step, i) => `${i + 1}. ${step.description}`)
						.join("\n")}\n\n---\nAll steps will be executed in order.`,
					language: "markdown",
				},
				{
					id: "setup",
					code: `# Setup and Imports
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
from pathlib import Path

# Create output directories
results_dir = Path('results')
figures_dir = Path('figures')
results_dir.mkdir(exist_ok=True)
figures_dir.mkdir(exist_ok=True)

print("Setup completed successfully!")`,
					language: "python",
				},
			];

			// Add analysis step cells with AI-generated code if available
			for (let i = 0; i < analysisSteps.length; i++) {
				const step = analysisSteps[i];
				let code: string;

				if (this.codeGenerationService && step.description) {
					// Use AI to generate analysis code
					const request: CodeGenerationRequest = {
						stepDescription: step.description,
						originalQuestion: query,
						datasets: datasets,
						workingDir: workspaceDir,
						stepIndex: i,
					};

					const result =
						await this.codeGenerationService.generateDataDrivenStepCode(
							request
						);
					code = result.code;
				} else {
					// Use existing code or fallback
					code =
						step.code ||
						`# ${step.description}\nprint("Analysis step ${i + 1}")`;
				}

				cells.push({
					id: `step-${i}`,
					code: code,
					language: "python",
					title: step.description,
				});
			}

			await this.createNotebook(notebookPath, cells);

			this.statusManager.updateStatus(
				"Unified analysis notebook generated successfully"
			);
			return notebookPath;
		} catch (error) {
			console.error(
				"NotebookService: Error generating unified notebook:",
				error
			);
			this.statusManager.updateStatus(
				"Failed to generate unified analysis notebook"
			);
			throw error;
		}
	}

	/**
	 * Set status callback for this service
	 */
	setStatusCallback(callback: (message: string) => void) {
		// Convert string callback to StatusUpdate callback
		this.statusManager.setStatusCallback((statusUpdate) => {
			callback(statusUpdate.message);
		});
	}

	/**
	 * Set code generation service for AI-powered notebook generation
	 */
	setCodeGenerationService(codeGenerationService: CodeGenerationService) {
		this.codeGenerationService = codeGenerationService;
	}
}
